plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
likelihood_infected(sar,total_cases,school_size)
likelihood_avoid(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",lik_from_inf/(lik_from_inf+lik_from_avoid)),
c("From infections: ",lik_from_avoid/(lik_from_avoid+lik_from_inf))))
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",lik_from_inf/(lik_from_inf+lik_from_avoid)),
c("From infections: ",lik_from_avoid/(lik_from_avoid+lik_from_inf))))
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3)))
d(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3)))))
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
# SAR sandbox
initial_cases <- 1
contacts_per_case <- 30
school_size <- 100
sar <- 0.05
# Simulation loop over generations
newcases <- initial_cases
total_cases <- initial_cases
store_cases <- initial_cases
while(newcases>0){
oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(remaining_susceptible*(contacts_per_case/school_size))
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
# SAR sandbox
initial_cases <- 1
contacts_per_case <- 30
school_size <- 100
sar <- 0.05
# Simulation loop over generations
newcases <- initial_cases
total_cases <- initial_cases
store_cases <- initial_cases
while(newcases>0){
oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(remaining_susceptible*(contacts_per_case/school_size))
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
# SAR sandbox
initial_cases <- 1
contacts_per_case <- 30
school_size <- 100
sar <- 0.05
# Simulation loop over generations
newcases <- initial_cases
total_cases <- initial_cases
store_cases <- initial_cases
while(newcases>0){
oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(remaining_susceptible*(contacts_per_case/school_size))
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
# SAR sandbox
initial_cases <- 1
contacts_per_case <- 30
school_size <- 100
sar <- 0.05
# Simulation loop over generations
newcases <- initial_cases
total_cases <- initial_cases
store_cases <- initial_cases
while(newcases>0){
oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(contacts_per_case* remaining_susceptible/school_size) # Estimate proportion of contacts susceptible
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
xx <- 124
xx*0.0874-0.0007*xx^2
xx <- seq(1,100)
xx*0.0874-0.0007*xx^2
xx <- seq(1,150)
xx*0.0874-0.0007*xx^2
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 1)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
## A.
# When you simulate the above model, you'll notice that currently the epidemics are nearly identical in the two populations.
# Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population.
# What happens to the size and timing of the epidemics?
# Answer:
## B. What happens if the epidemic starts with 10 people infected in both populations? Why does this happen?
# Answer:
## C.
# The model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2)
# The below code will plot these cumulative numbers of cases
# Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases
par( mfrow = c(1, 1))
plot( output$time, output$C1, type = "l", col = 4, lwd = 2, ylim = c(0, N1+100),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$C2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Cumulative cases in population 1", "Cumulative cases in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
# Hint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]
##### YOUR CODE GOES HERE #####
# D. What does the incidence look like if only 50% of the cases in population 2 are reported?
##### YOUR CODE GOES HERE #####
#Hint: There are several ways to do this - some are easier than others.
# E. If you have time, expand the model to include three populations (denoted 1, 2, 3).
# How would you model an epidemic where:
#  - mixing between population 1 and population 2 is 5% of the rate of mixing within these populations
#  - mixing between population 1 and population 3 is 10% of the rate of mixing within these populations
#  - there is no mixing between population 2 and population 3
##### YOUR CODE GOES HERE #####
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 10; I2_0 <- 10
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
par( mfrow = c(1, 1))
plot( output$time, output$C1, type = "l", col = 4, lwd = 2, ylim = c(0, N1+100),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$C2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Cumulative cases in population 1", "Cumulative cases in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
library(devtools)
install_github("epiverse-trace/epiparameter")
library(datadelay)
install_github("epiverse-trace/epiparameter")
library(epiparameter)
list_distributions()
library(tidyverse)
# Compile R package
library(roxygen2)
library(devtools)
library(tidyverse)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
setwd("~/Documents/GitHub/")
install("epiparameter")
incubation_H7N9 <- incubation_f(pathogen="influenza_H7N9")
list_distributions
list_distributions()
# Compile R package
library(roxygen2)
library(devtools)
library(tidyverse)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
install.packages("hardCode")
cat(a)
a
a <- 10
cat(a)
cat(a)
list_distributions()
incubation_H7N9 <- incubation_f(pathogen="influenza_H7N9")
incubation_H7N9
incubation_H7N9(10)
incubation_H7N9(5)
incubation_H7N9(2)
incubation_H7N9(1)
incubation_H7N9(0)
sum(incubation_H7N9(0:10))
# Convert functions - Donnelly
library(epitrix)
gamma_mucv2shapescale(4.85,sqrt(12.19)/4.85)
library(tidyverse)
setwd("~/Dropbox/LSHTM/TRACE_project/Sandbox_code_TRACE/epiparameter_dev/")
incubation_vals <- read_csv("parameters_incubation.csv")
onset_to_admission_vals <- read_csv("parameters_onset_admission.csv")
save(incubation_vals,onset_to_admission_vals,file="sysdata.rda")
save(incubation_vals,onset_to_admission_vals,file="/Users/akucharski/Documents/GitHub/epiparameter/sysdata.rda")
save(incubation_vals,onset_to_admission_vals,file="/Users/akucharski/Documents/GitHub/epiparameter/R/sysdata.rda")
# Compile R package
library(roxygen2)
library(devtools)
library(tidyverse)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
# Compile R package
library(roxygen2)
library(devtools)
library(tidyverse)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
