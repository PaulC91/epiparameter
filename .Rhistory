oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(remaining_susceptible*(contacts_per_case/school_size))
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
# SAR sandbox
initial_cases <- 1
contacts_per_case <- 30
school_size <- 100
sar <- 0.05
# Simulation loop over generations
newcases <- initial_cases
total_cases <- initial_cases
store_cases <- initial_cases
while(newcases>0){
oldcases <- newcases
remaining_susceptible <- (school_size-total_cases)
susceptible_contacts <- round(contacts_per_case* remaining_susceptible/school_size) # Estimate proportion of contacts susceptible
newcases <- rbinom(oldcases,susceptible_contacts,sar)
newcases <- sum(newcases)
store_cases <- c(store_cases,newcases)
total_cases <- total_cases + newcases
}
# Define likelihoods
likelihood_avoid <- function(sar_x,total_cases,school_size){
individual_lik <- (1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (school_size-total_cases)*log(individual_lik)
return(total_lik)
}
likelihood_infected <- function(sar_x,total_cases,school_size){
individual_lik <- 1-(1-sar_x)^(contacts_per_case*total_cases/school_size)
total_lik <- (total_cases)*log(individual_lik)
return(total_lik)
}
# Grid search to recover SAR
sar_x <- seq(0.01,0.1,0.01)
lik_out <- sapply(sar_x,function(x){likelihood_avoid(x,total_cases,school_size) + likelihood_infected(x,total_cases,school_size)})
MLE_SAR <- sar_x[which(lik_out==max(lik_out))]
# Plot profile likelihood with line at MLE
plot(sar_x,lik_out,xlab="SAR")
lines(c(MLE_SAR,MLE_SAR),c(-1e6,0),lty=2)
# Contribution to likelihood from each component
lik_from_avoid <- likelihood_avoid(sar,total_cases,school_size)
lik_from_inf <- likelihood_infected(sar,total_cases,school_size)
print(rbind(c("From avoided infections:",signif(lik_from_inf/(lik_from_inf+lik_from_avoid),3)),
c("From infections: ",signif(lik_from_avoid/(lik_from_avoid+lik_from_inf),3))))
xx <- 124
xx*0.0874-0.0007*xx^2
xx <- seq(1,100)
xx*0.0874-0.0007*xx^2
xx <- seq(1,150)
xx*0.0874-0.0007*xx^2
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 1)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
## A.
# When you simulate the above model, you'll notice that currently the epidemics are nearly identical in the two populations.
# Update the model parameters so the transmission rate between the two populations is equal to 5% of the transmission rate within each population.
# What happens to the size and timing of the epidemics?
# Answer:
## B. What happens if the epidemic starts with 10 people infected in both populations? Why does this happen?
# Answer:
## C.
# The model is currently set up to record the number of cumulative cases in each population (i.e. C1 and C2)
# The below code will plot these cumulative numbers of cases
# Update the code so you are plotting incidence, i.e. new cases appearing over time, rather than cumulative cases
par( mfrow = c(1, 1))
plot( output$time, output$C1, type = "l", col = 4, lwd = 2, ylim = c(0, N1+100),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$C2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Cumulative cases in population 1", "Cumulative cases in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
# Hint: Create a new variable that calculates the difference between adjacent timesteps, i.e. C1[2:t] - C1[1:(t-1)]
##### YOUR CODE GOES HERE #####
# D. What does the incidence look like if only 50% of the cases in population 2 are reported?
##### YOUR CODE GOES HERE #####
#Hint: There are several ways to do this - some are easier than others.
# E. If you have time, expand the model to include three populations (denoted 1, 2, 3).
# How would you model an epidemic where:
#  - mixing between population 1 and population 2 is 5% of the rate of mixing within these populations
#  - mixing between population 1 and population 3 is 10% of the rate of mixing within these populations
#  - there is no mixing between population 2 and population 3
##### YOUR CODE GOES HERE #####
######################################################
#              Metapopultions with ODEs             #
######################################################
# Load in the deSolve package
library(deSolve)
# If the package is not installed, install using the install.packages() function
## The code below has been written to solve a Susceptible-Infected-Recovered model with two populations.
# Familiarise yourself with the expanded model before moving onto the activities that follow.
# Note: the compartments C1 and C2 reflect the cumulative numbers of people infected. This will be used later on.
# # Define model function
SIR_metapop_model <- function(times, state, parms){
## Define variables
S1 <- state["S1"]
I1 <- state["I1"]
R1 <- state["R1"]
C1 <- state["C1"]
N1 <- S1 + I1 + R1
S2 <- state["S2"]
I2 <- state["I2"]
R2 <- state["R2"]
C2 <- state["C2"]
N2 <- S2 + I2 + R2
# Extract parameters
beta <- parms["beta"]
gamma <- parms["gamma"]
alpha <- parms["alpha"]
lambda1 <- (beta * I1 / N1 + alpha * beta * I2 / N2)
lambda2 <- (beta * I2 / N2 + alpha * beta * I1 / N1)
# Define differential equations
dS1 <- - lambda1 * S1
dI1 <- lambda1 * S1 - gamma * I1
dR1 <- gamma * I1
dC1 <- lambda1 * S1
dS2 <- - lambda2 * S2
dI2 <-  lambda2 * S2 - gamma * I2
dR2 <- gamma * I2
dC2 <- lambda2 * S2
res <- list(c(dS1, dI1, dR1, dC1, dS2, dI2, dR2, dC2))
return(res)
}
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 1; I2_0 <- 0
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
# Define parameters
parameters <- c( beta = 0.4, gamma = 0.1, alpha = 0.05)
# Define time to run model
times <- seq(from = 0, to = 50, by = 1)
# Define initial conditions
N1 <- 1000; N2 <- 1000
I1_0 <- 10; I2_0 <- 10
R1_0 <- 0; R2_0 <- 0
C1_0 <- 0; C2_0 <- 0
S1_0  <- N1 - I1_0
S2_0  <- N2 - I2_0
state <- c(S1 = S1_0, I1 = I1_0, R1 = R1_0, C1 = C1_0, S2 = S2_0, I2 = I2_0, R2 = R2_0, C2 = C2_0)
# Solve equations
output_raw <- ode(y = state, times = times, func = SIR_metapop_model, parms = parameters,
method = rk4)
# Convert to data frame for easy extraction of columns
output <- as.data.frame(output_raw)
# Plot output
par( mfrow = c(1, 1))
plot( output$time, output$I1, type = "l", col = 4, lwd = 2, ylim = c(0, N1),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$I2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Infected in population 1", "Infected in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
par( mfrow = c(1, 1))
plot( output$time, output$C1, type = "l", col = 4, lwd = 2, ylim = c(0, N1+100),
xlab = "Time", ylab = "Number", main = "")
lines( output$time, output$C2, lwd = 2, col = 2, type = "l")
legend("topright", legend = c("Cumulative cases in population 1", "Cumulative cases in population 2"),
lty = rep(1, 2), col = c(4, 2), lwd = 2, bty = "n")
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
# Compile R package
library(roxygen2)
library(devtools)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
# Compile R package
library(roxygen2)
library(devtools)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
?data
epiparameter::data()
epiparameter::data
epiparameter::inc_params
ata("inc_params.rds")
data("inc_params.rds")
data("data/inc_params.rds")
getwd()
load("data/inc_params.rds")
library(tidyverse)
setwd("~/Dropbox/LSHTM/TRACE_project/Sandbox_code_TRACE/epiparameter_dev/")
incubation_vals <- read_csv("incubation_parameters.csv")
save(incubation_vals,"sysdata.rda")
save
?save
getwd()
save(incubation_vals,"inc_vals","sysdata.rda")
incubation_vals
save(incubation_vals,"inc_vals","sysdata.RData")
library(tidyverse)
setwd("~/Dropbox/LSHTM/TRACE_project/Sandbox_code_TRACE/epiparameter_dev/")
incubation_vals <- read_csv("incubation_parameters.csv")
save(incubation_vals,file="sysdata.RData")
library(tidyverse)
setwd("~/Dropbox/LSHTM/TRACE_project/Sandbox_code_TRACE/epiparameter_dev/")
incubation_vals <- read_csv("incubation_parameters.csv")
save(incubation_vals,file="sysdata.rda")
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
incubation_vals
path="MERS_CoV"; study=NULL; pmf = T
incubation_vals %>% filter(pathogen==path)
library(tidyverse)
setwd("~/Dropbox/LSHTM/TRACE_project/Sandbox_code_TRACE/epiparameter_dev/")
incubation_vals <- read_csv("incubation_parameters.csv")
save(incubation_vals,file="sysdata.rda")
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
path="MERS_CoV"; study=NULL; pmf = T
# Extract relevant values
pick_path <- incubation_vals %>% filter(pathogen==path)
incubation_vals
pick_path <- incubation_vals %>% filter(pathogen_ID==pathogen)
pathogen="MERS_CoV"; study=NULL; pmf = T
# Extract relevant values
pick_path <- incubation_vals %>% filter(pathogen_ID==pathogen)
pick_path
study==NULL
pick_path %>% filter(size==max(size))
# Extract study or default to largest sample size
if( is.null(study) ){pick_study <- pick_path %>% filter(size==max(size))}
if(!is.null(study) ){pick_study <- pick_path %>% filter(study_ID==study)}
pick_study
pick_study$meanlog
dgamma(10,shape=5,scale=0.5)
dgamma(10,shape=5,scale=2)
dgamma(10,shape=5,scale=2)- pgamma(10,shape=5,scale=2)
pgamma(10,shape=5,scale=2)- pgamma(10,shape=5,scale=2)
pgamma(11,shape=5,scale=2)- pgamma(10,shape=5,scale=2)
pgamma(10,shape=5,scale=2)- pgamma(9,shape=5,scale=2)
?pgamma
incubation_f <- function(pathogen,study,pmf){
# DEBUG
# pathogen="MERS_CoV"; study=NULL; pmf = T
#inc_vals <- load("data/inc_params.rds")
# Extract pathogen
pick_path <- incubation_vals %>% filter(pathogen_ID==pathogen)
# Extract study or default to largest sample size
if( is.null(study) ){pick_study <- pick_path %>% filter(size==max(size))}
if(!is.null(study) ){pick_study <- pick_path %>% filter(study_ID==study)}
# Define distribution
if(pick_study$distribution=="lnorm"){
p_function <- function(x){plnorm(x,meanlog = pick_study$meanlog,sdlog = pick_study$sdlog)}
if(pmf==T){ out_function <- function(x){p_function(x+1)-p_function(x)} }
if(pmf==F){ out_function <- p_function }
}
if(pick_study$distribution=="gamma"){
p_function <- function(x){pgamma(x,shape = pick_study$shape,scale = pick_study$scale)}
if(pmf==T){ out_function <- function(x){out_function(x+1)-out_function(x)} }
if(pmf==F){ out_function <- p_function }
}
out_function
}
incubation_mers <- incubation_f(pathogen="MERS_CoV", study=NULL, pmf = T)
incubation_mers(1)
incubation_mers(10)
incubation_mers(0:10)
plot(1:10,incubation_mers(0:10))
plot(0:10,incubation_mers(0:10))
incubation_mers <- incubation_f(pathogen="MERS_CoV", study=NULL, pmf = F)
incubation_mers <- incubation_f(pathogen="influenza_H7N9", study=NULL, pmf = F)
plot(0:10,incubation_mers(0:10))
incubation_vals %>% select(pathogen_ID,study_ID,year,distribution)
incubation_vals %>% select(pathogen_ID,study_ID,year,size,distribution)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
list_distributions()
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
list_distributions()
# Install
setwd("~/Documents/GitHub/")
install("epiparameter")
library(epiparameter)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Compile R package
library(roxygen2)
library(devtools)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
# Compile R package
library(roxygen2)
library(devtools)
# Add documentation
setwd("~/Documents/GitHub/epiparameter")
document()
incubation_f
